package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"bytes"
	"context"
	"errors"
	"strings"

	"github.com/swiftwave-org/swiftwave/ssh_toolkit"
	"github.com/swiftwave-org/swiftwave/swiftwave_service/core"
	"github.com/swiftwave-org/swiftwave/swiftwave_service/graphql/model"
)

// CreateServer is the resolver for the createServer field.
func (r *mutationResolver) CreateServer(ctx context.Context, input model.NewServerInput) (*model.Server, error) {
	server := newServerInputToDatabaseObject(&input)
	err := core.CreateServer(&r.ServiceManager.DbClient, server)
	if err != nil {
		return nil, err
	}
	return serverToGraphqlObject(server), nil
}

// TestSSHAccessToServer is the resolver for the testSSHAccessToServer field.
func (r *mutationResolver) TestSSHAccessToServer(ctx context.Context, id uint) (bool, error) {
	command := "echo 'Hi'"
	server, err := core.FetchServerByID(&r.ServiceManager.DbClient, id)
	if err != nil {
		return false, err
	}
	err = ssh_toolkit.ExecCommandOverSSH(command, nil, nil, 10, server.IP, 22, server.User, r.Config.SystemConfig.SshPrivateKey, 20)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CheckDependenciesOnServer is the resolver for the checkDependenciesOnServer field.
func (r *mutationResolver) CheckDependenciesOnServer(ctx context.Context, id uint) ([]*model.Dependency, error) {
	server, err := core.FetchServerByID(&r.ServiceManager.DbClient, id)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Dependency, 0)
	for _, dependency := range core.RequiredServerDependencies {
		if dependency == "init" {
			continue
		}
		stdoutBuffer := new(bytes.Buffer)
		err = ssh_toolkit.ExecCommandOverSSH(core.DependencyCheckCommands[dependency], stdoutBuffer, nil, 5, server.IP, 22, server.User, r.Config.SystemConfig.SshPrivateKey, 30)
		if err != nil {
			if strings.Contains(err.Error(), "exited with status 1") {
				result = append(result, &model.Dependency{Name: dependency, Available: false})
				continue
			} else {
				return nil, err
			}
		}
		if stdoutBuffer.String() == "" {
			result = append(result, &model.Dependency{Name: dependency, Available: false})
		} else {
			result = append(result, &model.Dependency{Name: dependency, Available: true})
		}
	}
	return result, nil
}

// InstallDependenciesOnServer is the resolver for the installDependenciesOnServer field.
func (r *mutationResolver) InstallDependenciesOnServer(ctx context.Context, id uint) (bool, error) {
	_, err := core.FetchServerByID(&r.ServiceManager.DbClient, id)
	if err != nil {
		return false, err
	}
	// Queue the request
	// - create a server log
	// - push the request to the queue
	serverLog := &core.ServerLog{
		ServerID: id,
		Title:    "Installing dependencies",
	}
	err = core.CreateServerLog(&r.ServiceManager.DbClient, serverLog)
	if err != nil {
		return false, err
	}
	// Push the request to the queue
	err = r.WorkerManager.EnqueueInstallDependenciesOnServerRequest(id, serverLog.ID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// SetupServer is the resolver for the setupServer field.
func (r *mutationResolver) SetupServer(ctx context.Context, input model.ServerSetupInput) (bool, error) {
	server, err := core.FetchServerByID(&r.ServiceManager.DbClient, input.ID)
	if err != nil {
		return false, err
	}

	// Proceed request logic (reject in any other case)
	// - if, want to be manager
	//    - if, there are some managers already, need to be online any of them
	//    - if, no servers, then it will be the first manager
	// - if, want to be worker
	//   - there need to be at least one manager
	var swarmManagerServer *core.Server
	if input.SwarmMode == model.SwarmModeManager {
		// Check if there are some servers already
		exists, err := core.IsPreparedServerExists(&r.ServiceManager.DbClient)
		if err != nil {
			return false, err
		}
		if exists {
			// Try to find out if there is any manager online
			r, err := core.FetchSwarmManager(&r.ServiceManager.DbClient)
			if err != nil {
				return false, err
			}
			swarmManagerServer = &r
		}
	} else {
		// Check if there is any manager
		r, err := core.FetchSwarmManager(&r.ServiceManager.DbClient)
		if err != nil {
			return false, err
		}
		swarmManagerServer = &r
	}

	if swarmManagerServer == nil && input.SwarmMode == model.SwarmModeWorker {
		return false, errors.New("no manager found")
	}

	// NOTE: From here, if `swarmManagerServer` is nil, then this new server can be initialized as first swarm manager

	// Fetch hostname
	hostnameStdoutBuffer := new(bytes.Buffer)
	err = ssh_toolkit.ExecCommandOverSSH("cat /etc/hostname", hostnameStdoutBuffer, nil, 10, server.IP, 22, server.User, r.Config.SystemConfig.SshPrivateKey, 20)
	if err != nil {
		return false, err
	}
	hostname := strings.TrimSpace(hostnameStdoutBuffer.String())
	server.HostName = hostname
	err = core.UpdateServer(&r.ServiceManager.DbClient, server)

	return false, errors.New("not implemented " + hostname)
}

// Servers is the resolver for the servers field.
func (r *queryResolver) Servers(ctx context.Context) ([]*model.Server, error) {
	servers, err := core.FetchAllServers(&r.ServiceManager.DbClient)
	if err != nil {
		return nil, err
	}
	serverList := make([]*model.Server, 0)
	for _, server := range servers {
		serverList = append(serverList, serverToGraphqlObject(&server))
	}
	return serverList, nil
}

// Logs is the resolver for the logs field.
func (r *serverResolver) Logs(ctx context.Context, obj *model.Server) ([]*model.ServerLog, error) {
	serverLogs, err := core.FetchServerLogByServerID(&r.ServiceManager.DbClient, obj.ID)
	if err != nil {
		return nil, err
	}
	serverLogList := make([]*model.ServerLog, 0)
	for _, serverLog := range serverLogs {
		serverLogList = append(serverLogList, serverLogToGraphqlObject(&serverLog))
	}
	return serverLogList, nil
}

// Server returns ServerResolver implementation.
func (r *Resolver) Server() ServerResolver { return &serverResolver{r} }

type serverResolver struct{ *Resolver }
